CURSOR RULES (DASH FORMAT ONLY)

1. DBT + MIGRATION CONTEXT
- DBT models live under models/.
- Client-specific models live under models/clients/<client_name_folder>.
- CRM template models live under models/<crm_template_folder>.
- Parent directory contains: .env with Redshift credentials, migration_config.yml with client_name, source_crm, source_schema, target_schema, master_id.
- Cursor must never invent schema fields or warehouse assumptions.
- Cursor must ask the user whenever any structure, field, or requirement is unclear.

2. DBT KNOWLEDGE BASE (CRM + TABLE)
- crm/ holds general rules for how each CRM behaves (naming patterns, null patterns, joins, location structure, etc).
- table/ holds per-table quirks, fallback rules, field nuances, column expectations, known issues.
- Cursor must always consult crm/ for CRM-wide behaviour.
- Cursor must always consult table/ for table-level rules.
- Cursor must combine crm/ + table/ knowledge when reasoning about any transformation.

3. DATA AND MODEL INVESTIGATION RULES
- migration_config.yml is the single source of truth for client_name, source_crm, source_schema, target_schema, master_id.
- .env is the source of truth for Redshift connection variables.
- Cursor must use these values to determine source_schema (raw data) and target_schema (final tables).
- Cursor must identify which table each DBT model materializes to.
- If any required field, structure, grain, or relationship is unclear, Cursor must ask the user.
- Cursor may generate SQL but must not run commands.

4. REDSHIFT ACCESS (CONCEPTUAL ONLY)
- Redshift credentials include host, port, database, username, password.
- Cursor must assume the user loads these into the environment.
- Cursor must not hardcode credentials.
- Cursor must ask the user if credentials appear inconsistent or missing.

5. DBT MODEL WORKFLOW
- CRM templates live under models/<crm_template_folder>.
- Client-specific models live under models/clients/<client_name_folder>.
- Only edit client-specific models unless the user explicitly approves template-level changes.
- Cursor must identify the target table of any model using target_schema.
- Cursor must check how the table is used downstream in DBT and QA.
- If grain, keys, or join logic are unclear, Cursor must ask the user.
- Cursor must apply crm/ and table/ knowledge consistently.

6. MODEL INVESTIGATION FLOW
- Identify the DBT model file and its full namespace.
- Determine the target table using target_schema.
- Examine joins, filters, keys, aggregations, mapping tables, and assumptions.
- Suggest SQL to inspect row counts, nulls, duplicates, or unexpected patterns.
- Ask the user clarifying questions such as:
  - should this field exist?
  - should this be unique?
  - is null acceptable?
  - is this mapping table valid?
- Cursor must not change business behaviour when requirements are unclear.

7. WRAPPER SCRIPT VS MANUAL RUNS (CONCEPTUAL)
- A wrapper script exists in the parent directory and prepares env variables and runs DBT.
- Cursor should treat the wrapper script as the default execution path.
- Cursor must refer to DBT execution conceptually and must not include literal DBT commands.

8. QA SUITE (CONCEPTUAL RULES)
- After DBT models run, the QA Suite validates table groups and full sweeps.
- QA expects specific tables and fields in target_schema.
- When a QA failure occurs, Cursor must:
  - trace the failure back to the responsible DBT model,
  - identify missing or incorrect fields,
  - propose precise updates,
  - ask for confirmation when business behaviour is unclear.
- Cursor must speak about QA conceptually and avoid specific commands.

9. MODIFICATION GUARDRAILS
- Cursor must only modify models/clients/<client_name_folder> unless instructed otherwise.
- Cursor must preserve dbt_project.yml and profiles.yml.
- Cursor must avoid global changes unless the user explicitly approves them.
- Cursor must ask if a proposed change affects multiple clients or CRM templates.

10. DATA INVESTIGATION (REQUIRED SQL STEP)
- When the user asks about missing values, coverage, fallbacks, enrichment, or field quality, Cursor must:
  - identify the source table in source_schema,
  - generate SQL to inspect raw CRM fields,
  - show SQL before suggesting any modelling fix,
  - use SQL patterns (null rates, distinct values, distribution) for reasoning,
  - ask user if deeper inspection is required,
  - never execute SQL itself.
- Automatic SQL generation is required for questions such as:
  - boost location coverage
  - missing locality or metro fields
  - fallback city/state/country logic
  - phone/email/title/industry coverage
  - any CRM field completeness
- SQL inspection must occur before any DBT model suggestion.

11. REQUIRED SQL INSPECTION RULE
- Cursor must always inspect raw data via SQL before proposing DBT changes.
- Cursor must identify the correct table under source_schema.
- Cursor must present SQL immediately.
- Cursor must ask the user when assumptions involve CRM-specific or client-specific nuances.
- Cursor must use SQL results to guide recommendations, not assumptions.

END OF RULESET
